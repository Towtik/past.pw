<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Sunset Landscape</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent scrolling */
            background-color: #000;
            font-family: sans-serif;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* Subtle overlay to give a cinematic, film-grain feel */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background-image: url('data:image/svg+xml;utf8,%3Csvg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noiseFilter"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.65" numOctaves="3" stitchTiles="stitch"/%3E%3C/filter%3E%3Crect width="100%25" height="100%25" filter="url(%23noiseFilter)" opacity="0.04"/%3E%3C/svg%3E');
            z-index: 10;
        }
    </style>
</head>
<body>

    <canvas id="sunsetCanvas"></canvas>
    <div class="overlay"></div>

    <script>
        const canvas = document.getElementById('sunsetCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        
        let width, height;
        let time = 0;

        // Entities arrays
        let grassBlades = [];
        let birds = [];
        let clouds = [];
        let stars = [];

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            
            initGrass();
            initBirds();
            initClouds();
            initStars();
        }

        window.addEventListener('resize', resize);

        // --- 1D Noise Engine for Realistic Terrain ---
        function hash(n) {
            let h = Math.sin(n) * 43758.5453123;
            return h - Math.floor(h);
        }

        function noise(x) {
            const fl = Math.floor(x);
            const fc = x - fl;
            // Smoothstep for natural interpolation
            const u = fc * fc * (3.0 - 2.0 * fc);
            return hash(fl) * (1.0 - u) + hash(fl + 1.0) * u;
        }

        function getElevation(x, amplitude, frequency) {
            let elevation = 0;
            let amp = amplitude;
            let freq = frequency;
            for (let i = 0; i < 6; i++) { // 6 Octaves for high detail
                let n = noise(x * freq);
                // Apply "Ridge Noise" to higher frequencies for sharp, rocky peaks
                if (i > 1) {
                    n = 1.0 - Math.abs(n * 2.0 - 1.0);
                    n *= n; 
                }
                elevation += n * amp;
                amp *= 0.5;
                freq *= 2.0;
            }
            return elevation;
        }

        // --- Entity Initializers ---
        function initStars() {
            stars = [];
            for(let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * width,
                    y: Math.random() * height * 0.6, // Only upper sky
                    r: Math.random() * 1.2,
                    twinkle: Math.random() * Math.PI * 2,
                    twinkleSpeed: 0.01 + Math.random() * 0.02
                });
            }
        }

        function initClouds() {
            clouds = [];
            for(let i = 0; i < 18; i++) {
                clouds.push({
                    x: Math.random() * width,
                    y: Math.random() * height * 0.45,
                    w: 150 + Math.random() * 400,
                    h: 15 + Math.random() * 35,
                    speed: 0.02 + Math.random() * 0.08,
                    opacity: 0.05 + Math.random() * 0.25,
                    // Clouds lower down catch orange/gold light, higher ones catch crimson/purple
                    color: Math.random() > 0.5 ? '249, 168, 77' : '212, 83, 65' 
                });
            }
        }

        function initGrass() {
            grassBlades = [];
            const density = Math.floor(width * 3.5); // Denser meadow
            
            for (let i = 0; i < density; i++) {
                // Subtle organic color variations instead of pure black
                const depthColor = 3 + Math.random() * 15;
                
                grassBlades.push({
                    x: Math.random() * width,
                    h: 15 + Math.random() * (height * 0.2),
                    thick: 0.8 + Math.random() * 1.5,
                    color: `rgb(${depthColor + 5}, ${depthColor}, ${depthColor + 8})`,
                    swaySpeed: 0.0005 + Math.random() * 0.001,
                    swayOffset: Math.random() * Math.PI * 2,
                    curveForce: (Math.random() - 0.5) * 30
                });
            }
        }

        function initBirds() {
            birds = [];
            for (let i = 0; i < 12; i++) {
                birds.push({
                    x: Math.random() * width * 1.5 - width * 0.25,
                    y: height * 0.1 + Math.random() * (height * 0.35),
                    size: 0.8 + Math.random() * 1.2,
                    speed: 0.2 + Math.random() * 0.4,
                    wingSpeed: 0.03 + Math.random() * 0.04,
                    offset: Math.random() * 100,
                    drift: (Math.random() - 0.5) * 0.15
                });
            }
        }

        // --- Rendering Functions ---
        function drawSky() {
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            
            gradient.addColorStop(0.0, '#0b041c');   // Midnight blue/purple
            gradient.addColorStop(0.3, '#38143d');   // Deep plum
            gradient.addColorStop(0.55, '#8c223c');  // Crimson
            gradient.addColorStop(0.75, '#de573c');  // Fiery orange
            gradient.addColorStop(1.0, '#ffb84d');   // Golden horizon

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
        }

        function drawStars() {
            stars.forEach(s => {
                s.twinkle += s.twinkleSpeed;
                const opacity = (Math.sin(s.twinkle) + 1) * 0.5 * 0.8;
                const horizonFade = Math.max(0, 1 - (s.y / (height * 0.6))); // Fade near sunset light
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity * horizonFade})`;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawSun() {
            const sunX = width * 0.5;
            const sunY = height * 0.65;
            const sunRadius = Math.min(width, height) * 0.12;

            // Wide atmospheric scattering
            const scatterGrad = ctx.createRadialGradient(sunX, sunY, sunRadius, sunX, sunY, sunRadius * 4.5);
            scatterGrad.addColorStop(0, 'rgba(255, 210, 120, 0.6)');
            scatterGrad.addColorStop(0.4, 'rgba(230, 100, 50, 0.2)');
            scatterGrad.addColorStop(1, 'rgba(150, 30, 50, 0)');
            
            ctx.fillStyle = scatterGrad;
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunRadius * 4.5, 0, Math.PI * 2);
            ctx.fill();

            // Core sun
            const sunGrad = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunRadius);
            sunGrad.addColorStop(0, '#ffffff');
            sunGrad.addColorStop(0.2, '#fff4d6');
            sunGrad.addColorStop(0.7, '#ffac33');
            sunGrad.addColorStop(1, 'rgba(255, 172, 51, 0)');

            ctx.fillStyle = sunGrad;
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawClouds() {
            clouds.forEach(c => {
                c.x -= c.speed;
                if (c.x + c.w < -100) c.x = width + 50;

                const cx = c.x + c.w / 2;
                const cy = c.y + c.h / 2;
                
                // Soft volumetric gradient for clouds
                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, c.w / 2);
                grad.addColorStop(0, `rgba(${c.color}, 1)`);
                grad.addColorStop(0.4, `rgba(${c.color}, 0.6)`);
                grad.addColorStop(1, `rgba(${c.color}, 0)`);

                ctx.globalAlpha = c.opacity;
                ctx.fillStyle = grad;
                
                // Draw as stretched, flattened ellipses
                ctx.save();
                ctx.translate(cx, cy);
                ctx.scale(1, c.h / c.w);
                ctx.beginPath();
                ctx.arc(0, 0, c.w / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
            ctx.globalAlpha = 1.0; // Reset
        }

        function drawMountainLayer(yOffset, amplitude, frequency, colorTop, colorBottom, seedOffset) {
            const gradient = ctx.createLinearGradient(0, height - yOffset - amplitude * 2, 0, height);
            gradient.addColorStop(0, colorTop);
            gradient.addColorStop(1, colorBottom);

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(0, height);
            
            for (let x = 0; x <= width; x += 3) { // Higher resolution step
                let y = height - yOffset + getElevation(x + seedOffset, amplitude, frequency);
                ctx.lineTo(x, y);
            }
            
            ctx.lineTo(width, height);
            ctx.closePath();
            ctx.fill();
        }

        function drawForeground() {
            ctx.fillStyle = '#050204'; 
            ctx.beginPath();
            ctx.moveTo(0, height);
            ctx.lineTo(0, height - Math.min(height * 0.1, 50));
            
            ctx.quadraticCurveTo(width / 2, height - Math.min(height * 0.15, 80), width, height - Math.min(height * 0.08, 40));
            
            ctx.lineTo(width, height);
            ctx.closePath();
            ctx.fill();
        }

        function drawGrass() {
            ctx.lineCap = 'round';
            
            grassBlades.forEach(blade => {
                ctx.strokeStyle = blade.color;
                ctx.lineWidth = blade.thick;
                ctx.beginPath();
                
                let wind = Math.sin(time * blade.swaySpeed + blade.swayOffset) * 15;
                
                let startY = height;
                let endY = height - blade.h;
                
                ctx.moveTo(blade.x, startY);
                ctx.quadraticCurveTo(
                    blade.x + blade.curveForce + wind * 0.6, 
                    startY - blade.h * 0.5, 
                    blade.x + wind + blade.curveForce, 
                    endY
                );
                ctx.stroke();
            });
        }

        function drawBirds() {
            ctx.fillStyle = '#11050e'; 
            
            birds.forEach(bird => {
                bird.x -= bird.speed;
                bird.y += bird.drift;

                if (bird.x < -50) {
                    bird.x = width + 50;
                    bird.y = height * 0.1 + Math.random() * (height * 0.3);
                }

                let wingSway = Math.sin(time * bird.wingSpeed + bird.offset);
                let wingHeight = bird.size * 3 * wingSway;
                
                ctx.beginPath();
                ctx.moveTo(bird.x - bird.size * 4, bird.y - wingHeight);
                ctx.quadraticCurveTo(bird.x, bird.y + bird.size, bird.x, bird.y + bird.size * 1.5);
                ctx.quadraticCurveTo(bird.x, bird.y + bird.size, bird.x + bird.size * 4, bird.y - wingHeight);
                ctx.lineTo(bird.x, bird.y);
                ctx.closePath();
                ctx.fill();
            });
        }

        function render() {
            time += 16; 

            drawSky();
            drawStars();
            drawSun();
            drawClouds();

            // Refined atmospheric colors for depth
            drawMountainLayer(height * 0.35, Math.min(width, height) * 0.12, 0.002, '#5e213b', '#de573c', 1000);
            drawMountainLayer(height * 0.22, Math.min(width, height) * 0.10, 0.0035, '#3b122b', '#8c223c', 5000);
            drawMountainLayer(height * 0.12, Math.min(width, height) * 0.08, 0.006, '#1a0614', '#38143d', 9000);

            drawBirds();
            drawForeground();
            drawGrass();

            requestAnimationFrame(render);
        }

        // Initialize and start
        resize();
        render();

    </script>
</body>
</html>
